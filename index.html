<title>Maziacs</title>

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

<style>
    body {
        margin: 0;
        height: 100%;
        overflow: hidden;
    }
    #stage {
        cursor: default;
        display: block;
        width: 100%;
        height: 100%;
    }
    #debug {
        position: absolute;
        top: -1px;
        right: -1px;
        background-color: white;
        border: 1px solid #000;
        width: 100px;
        height: 50px;
        overflow: hidden;
    }
</style>

<script src="sprint-master/sprint.js"></script>

<script>
(function() {

"use strict";

var mouseX;
var mouseY;

var canvas;
var c;
var cWidth;
var cHeight;

var maze= [];
var mazeWidth= 41;
var mazeHeight= 31;

var pxMazeWidth;
var pxMazeHeight;

var viewX;
var viewY;

var pxTileWidth= 48;
var pxTileHeight= 48;
var pxTileWidth2= pxTileWidth / 2;
var pxTileHeight2= pxTileHeight / 2;

var pxPlayerWidth= 20;
var pxPlayerHeight= 20;

var borderX= 2;
var borderY= 2;

var FRAME= -1;
var FLOOR= 0;
var WALL= 1;

var initMaze= function() {

    pxMazeWidth= pxTileWidth * mazeWidth;
    pxMazeHeight= pxTileHeight * mazeHeight;
    viewX= pxMazeWidth / 2;
    viewY= pxMazeHeight / 2;

    for ( var y= 0; y <= mazeHeight + 1; y++ ) {
        maze[y]= [];
        maze[y][0]= FRAME;
        maze[y][mazeWidth + 1]= FRAME;
    }

    for ( var x= 1; x <= mazeWidth; x++ ) {
        maze[0][x]= FRAME;
        maze[mazeHeight + 1][x]= FRAME;
    }

    for ( var y= 1; y <= mazeHeight; y++ ) {
        for ( var x= 1; x <= mazeWidth; x++ ) {
            maze[y][x]= Math.random() < .5 ? WALL : FLOOR;
        }
    }

//     console.table(maze);
}


// =============================================================================
//  Projection
// =============================================================================

// Static, to prevent GCs
var projX= [];
var projY= [];

var playerProjX;
var playerProjY;

var calcTileProj= function( pos, proj, p ) {

    var PI_2= Math.PI / 2;

    var pxTargetSize= p.pxTargetSize;
    var pxTileSize= p.pxTileSize;
    var border= p.border;
    var mazeSize= p.mazeSize;

    var pxBorder= border * pxTileSize;
    var pxMazeSize= pxTileSize * mazeSize;
    var pxMazeMove= pxTargetSize - pxMazeSize;

    if ( pxMazeMove > 0 ) pxMazeMove= 0;

    var pxTile0= pxMazeMove * pos / pxMazeSize;
    var pxTileN= pxTile0 + pxMazeSize;

    var borderTile0= -1;
    var borderTile1= mazeSize;

    var pxTile= pxTile0;

    // <= !! Ein zusaetzlicher Wert wird noch benoetigt
    for ( var tile= 0; tile <= mazeSize; tile++ ) {

        if ( pxTile < pxBorder ) {
            borderTile0= tile;

            var fTile= (pxTile - pxTile0) / (pxBorder - pxTile0);
            proj[tile]= (1 - Math.sin(PI_2 + PI_2 * fTile)) * pxBorder;
        }
        else if ( pxTile >= pxTargetSize - pxBorder ) {
            if ( borderTile1 == mazeSize ) borderTile1= tile;

            var fTile= (pxTile - pxTileN) / (pxTargetSize - pxBorder - pxTileN);
            proj[tile]= pxTargetSize - (1 - Math.sin(PI_2 + PI_2 * fTile)) * pxBorder;
        }
        else {
            proj[tile]= pxTile;
        }

        pxTile += pxTileSize;
    }

    // Zu breite Tiles abschmaelern (Passiert durch Sinus)
    for ( ; borderTile0 >= 0; borderTile0-- ) {
        if ( proj[borderTile0 + 1] - proj[borderTile0] > pxTileSize ) {
            proj[borderTile0]= proj[borderTile0 + 1] - pxTileSize;
        }
    }

    for ( ; borderTile1 < mazeSize; borderTile1++ ) {
        if ( proj[borderTile1] - proj[borderTile1 - 1] > pxTileSize ) {
            proj[borderTile1]= proj[borderTile1 - 1] + pxTileSize;
        }
    }
};

var proj= function( x, y ) {
    var mazeX= Math.floor(x / pxTileWidth);
    var mazeY= Math.floor(y / pxTileHeight);
    var fracX= (x % pxTileWidth) / pxTileWidth;
    var fracY= (y % pxTileHeight) / pxTileHeight;
    return [ projX[mazeX] + (projX[mazeX + 1] - projX[mazeX]) * fracX
           , projY[mazeY] + (projY[mazeY + 1] - projY[mazeY]) * fracY ];
};

// TODO: Optimieren falls oefter benoetigt
var invProj= function( x, y ) {
    for ( var xi= projX.length - 2; xi >= 0; xi-- ) {
        if ( x >= projX[xi] ) {
            for ( var yi= projY.length - 2; yi >= 0; yi-- ) {
                if ( y >= projY[yi] ) {
                    return [ (xi + (x - projX[xi]) / (projX[xi + 1] - projX[xi])) * pxTileWidth
                           , (yi + (y - projY[yi]) / (projY[yi + 1] - projY[yi])) * pxTileHeight ];
                }
            }
            return;
        }
    }
};

var calcProjs= function() {

    calcTileProj(viewX, projX, {
        pxTargetSize: cWidth,
        pxTileSize: pxTileWidth,
        border: borderX,
        mazeSize: mazeWidth,
    });

    calcTileProj(viewY, projY, {
        pxTargetSize: cHeight,
        pxTileSize: pxTileHeight,
        border: borderY,
        mazeSize: mazeHeight,
    });

    var playerProj= proj(viewX, viewY);
    playerProjX= playerProj[0];
    playerProjY= playerProj[1];
};


// =============================================================================
//  Draw Canvas
// =============================================================================

var drawRect= function( x, y, w, h, hue ) {
    c.fillStyle= 'hsl(' + hue + ',100%,60%)';
    c.fillRect(x - w / 2, y - h / 2, w, h);
};

var drawMaze= function() {
    var c_= c; // Localize

    for ( var mazeY= 0; mazeY < mazeHeight; mazeY++ ) {
        for ( var mazeX= 0; mazeX < mazeWidth; mazeX++ ) {

            var px0= projX[mazeX];
            var px1= projX[mazeX + 1]
            var py0= projY[mazeY];
            var py1= projY[mazeY + 1]

            var content= maze[mazeY + 1][mazeX + 1];

            if ( content == WALL ) {
                c_.fillStyle = 'rgb(' + Math.floor(255 * mazeX / mazeWidth) + ',' + (((mazeX + mazeY) & 1) ? 100 : 0) + ',0)';
            }
            else {
                c_.fillStyle = 'rgb(255,255,255)';
            }
            c_.fillRect(px0, py0, px1 - px0, py1 - py0);
        }
    }
}

var drawPlayer= function() {
    drawRect(playerProjX, playerProjY, pxPlayerWidth, pxPlayerHeight, 20);
};

var redraw= function() {
    calcProjs();

    c.clearRect(0, 0, cWidth, cHeight);

    drawMaze();
    drawPlayer();
};

var lastTimestamp;
var step= function( timestamp ) {
    if ( !lastTimestamp ) lastTimestamp= timestamp;
    var duration= timestamp - lastTimestamp;
    if ( duration >= 40 ) {

        lastTimestamp= timestamp;

        $('#debug').html(1000 / duration);

        redraw();
    }
    window.requestAnimationFrame(step);
};

window.requestAnimationFrame(step);

// setInterval(initMaze, 2000);

var resizeCanvas= function() {
    canvas.width= cWidth= window.innerWidth;
    canvas.height= cHeight= window.innerHeight;
    redraw();
};


// =============================================================================
//  Mouse
// =============================================================================

var MOUSE_CLICK_DELAY= 300;

var mousePress;
var mousePressTimestamp;
var playerIsMoving;

var onMouseMove= function( e ) {
    if ( e.changedTouches && e.changedTouches.length > 0 ) {
        mouseX= e.changedTouches[0].clientX;
        mouseY= e.changedTouches[0].clientY;
        return;
    }
    mouseX= e.clientX;
    mouseY= e.clientY;
};

var onMouseDown= function( e ) {
    onMouseMove(e);
    mousePressTimestamp= e.timeStamp;
    playerIsMoving= undefined;
}

var onMouseUp= function( e ) {
    if ( e.timeStamp - mousePressTimestamp < MOUSE_CLICK_DELAY ) {
        console.log("click", e);
        // click;
    }
    mousePressTimestamp= undefined;
    if ( e.cancelable ) e.preventDefault();
};


// =============================================================================
//  Game Logic
// =============================================================================

var dirs= [
    [ 0, -1 ], [ -1, -1 ], [ -1, 0 ], [ -1, 1 ], [ 0, 1 ], [ 1, 1 ], [ 1, 0 ], [ 1, -1 ], [ 0, -1 ]
];

var GAME_SPEED= 50;
var PLAYER_SPEED= 3000 / GAME_SPEED;

var fixMoves= [
    [ 0, 1, 1, 1, 4, 0, 2, 3, 4, 8, 0, 9, 4, 12, 6, 0 ],
    [ 0, 8, 2, 1, 2, 0, 2, 3, 8, 8, 0, 9, 4, 12, 6, 0 ],
];

var _movePlayer= function( viewX_, viewY_ ) {

    var viewX1;
    var viewY1;
    var mazeX;
    var mazeY= Math.floor(viewY / pxTileHeight);

    var mazeX0= Math.floor((viewX_ - pxPlayerWidth / 2) / pxTileWidth);
    var mazeY0= Math.floor((viewY_ - pxPlayerHeight / 2) / pxTileHeight);
    var mazeX1= Math.floor((viewX_ + pxPlayerWidth / 2) / pxTileWidth);
    var mazeY1= Math.floor((viewY_ + pxPlayerHeight / 2) / pxTileHeight);

    var floor00= maze[mazeY0 + 1][mazeX0 + 1] !== FLOOR ? 1 : 0;
    var floor01= maze[mazeY0 + 1][mazeX1 + 1] !== FLOOR ? 2 : 0;
    var floor11= maze[mazeY1 + 1][mazeX1 + 1] !== FLOOR ? 4 : 0;
    var floor10= maze[mazeY1 + 1][mazeX0 + 1] !== FLOOR ? 8 : 0;

    var floor= floor00 + floor01 + floor10 + floor11;
    if ( floor ) {
        var action= fixMoves[Math.abs(viewX1 - viewX) > Math.abs(viewY1 - viewY) ? 0 : 1][floor];
        if ( action === 0 ) return;

        if ( action & 1 ) viewY_= mazeY1 * pxTileHeight + pxPlayerHeight / 2;
        if ( action & 2 ) viewX_= mazeX0 * pxTileWidth + pxTileWidth - pxPlayerWidth / 2;
        if ( action & 4 ) viewY_= mazeY0 * pxTileHeight + pxTileHeight - pxPlayerHeight / 2;
        if ( action & 8 ) viewX_= mazeX1 * pxTileWidth + pxPlayerWidth / 2;
    }

    viewX= viewX_;
    viewY= viewY_;
}

var movePlayer= function() {
    if ( playerProjX === undefined ) return;
    if ( mousePressTimestamp === undefined ) return;
    if ( mousePressTimestamp < MOUSE_CLICK_DELAY ) return;

    var dx= mouseX - playerProjX;
    var dy= mouseY - playerProjY;
    var dist= dx * dx + dy * dy;

    // Min. 20px (20^2)
    if ( dist < 400 ) {
        if ( playerIsMoving ) {
            var view= invProj(mouseX, mouseY);

            // mouseX/mouseY may be out of range
            if ( view !== undefined ) _movePlayer(view[0], view[1]);
        }
        return;
    }

    playerIsMoving= true;

    var dirIndex= Math.floor((Math.atan2(dx, dy) + Math.PI / 8) * 4 / Math.PI) + 4;
    var dirX= dirs[dirIndex][0];
    var dirY= dirs[dirIndex][1];

    _movePlayer(viewX + dirX * cWidth / PLAYER_SPEED, viewY + dirY * cHeight / PLAYER_SPEED);
};

var gameLogic= function() {
    movePlayer();
}


// =============================================================================
//  Init
// =============================================================================

setInterval(gameLogic, GAME_SPEED);

var init= function() {

    initMaze();

    canvas= document.getElementById('stage');
    c= canvas.getContext('2d');

    window.addEventListener('resize', resizeCanvas, false);
    resizeCanvas();

    window.addEventListener('touchstart', onMouseDown, false);
    window.addEventListener('mousedown', onMouseDown, false);
    window.addEventListener('touchmove', onMouseMove, false);
    window.addEventListener('mousemove', onMouseMove, false);
    window.addEventListener('touchend', onMouseUp, false);
    window.addEventListener('mouseup', onMouseUp, false);
};

$(function() {
    init();

});

})();
</script>

<div id="debug"></div>
<canvas id="stage"></canvas>
