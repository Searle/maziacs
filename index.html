<title>Maziacs</title>

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

<style>
    body {
        margin: 0;
        height: 100%;
        overflow: hidden;
    }
    #stage {
        cursor: default;
        display: block;
        width: 100%;
        height: 100%;
    }
    #debug {
        position: absolute;
        top: -1px;
        right: -1px;
        background-color: white;
        border: 1px solid #000;
        width: 100px;
        height: 50px;
        overflow: hidden;
    }
</style>

<Xscript src="sprint-master/sprint.js"></Xscript>

<script>
(function() {

"use strict";

var DEBUG= true;

var mouseX;
var mouseY;

var canvas;
var c;
var cWidth;
var cHeight;

var maze= [];
var mazeWidth= 7;
var mazeHeight= 7;

var dists;
var items;

var pxMazeWidth;
var pxMazeHeight;

var pxPlayerX;
var pxPlayerY;

var monsters;

var pxTileWidth= 48;
var pxTileHeight= 48;
var pxTileWidth2= pxTileWidth / 2;
var pxTileHeight2= pxTileHeight / 2;

var pxPlayerWidth= 20;
var pxPlayerHeight= 20;

var borderX= 2;
var borderY= 2;

var DOOR= -5;
var KEY= -4;
var CALC= -3;
var FRAME= -2;
var WALL= -1;
var FLOOR= 0;
var FLOOR_CALC= 0;

var dirs= [ [ 0, -1 ], [ 1, 0 ], [ 0, 1 ], [ -1, 0 ] ];

var random= function( from, until ) {
    return Math.floor(Math.random() * (until - from) + from);
};

var randomf= function( from, until ) {
    return Math.random() * (until - from) + from;
};


// =============================================================================
//  Calculate distances from point in maze
// =============================================================================

var calcDistances= function( startPosX, startPosY ) {

    var distance= 0;
    var key= startPosX + ':' + startPosY;
    var queue= [ [ key, startPosX, startPosY, distance ] ];
    var maxDistanceKey= key;
    var maxDistance= distance;

    var lookup= {};
    lookup[key]= [ startPosX, startPosY, distance, undefined ];

    var byDistance= [ [ key ] ];
    var deadEnds= [];

    while ( queue.length > 0 ) {
        var pos= queue.pop();
        var key= pos[0];
        var posX= pos[1];
        var posY= pos[2];
        var distance= pos[3] + 1;

        var isDeadEnd= true;
        for ( var dir= 0; dir < 4; dir++ ) {
            var nextPosX= posX + dirs[dir][0];
            var nextPosY= posY + dirs[dir][1];
            if ( maze[nextPosY][nextPosX] < FLOOR_CALC ) continue;

            var nextKey= nextPosX + ':' + nextPosY;
            if ( nextKey in lookup ) continue;

            lookup[nextKey]= [ nextPosX, nextPosY, distance, key ];

            // Children merken, falls benoetigt
            // lookup[key].push(nextKey);

            if ( byDistance.length - 1 < distance ) {
                byDistance[distance]= [ nextKey ];
            }
            else {
                byDistance[distance].push(nextKey);
            }

            queue.push([ nextKey, nextPosX, nextPosY, distance ]);
            isDeadEnd= false;

            if ( distance > maxDistance ) {
                maxDistanceKey= nextKey;
                maxDistance= distance;
            }
        }
        if ( isDeadEnd ) {
            deadEnds.push(key);
        }
    }

    return {
        lookup: lookup,
        maxDistanceKey: maxDistanceKey,
        maxDistance: maxDistance,
        byDistance: byDistance,
        deadEnds: deadEnds,
    };
};


// =============================================================================
//  Generate new maze
// =============================================================================

// Generate Doors & Keys
var genItems= function() {
    items= {};

    var lookup= dists.lookup;
    var maxDistance= dists.maxDistance;
    var maxDistanceKey= dists.maxDistanceKey;
    var deadEnds= dists.deadEnds;

    var solution= [];
    var solutionLookup= {};

    var key= maxDistanceKey;
    while ( key ) {
        solutionLookup[key]= maxDistance - solution.length; // == lookup[key][2]
        solution.unshift([ key ]);
        key= lookup[key][3];
    }

    for ( var i= 0; i < deadEnds.length; i++ ) {
        var key= deadEnds[i];
        if ( key === maxDistanceKey ) continue;

        var prevKey= undefined;
        while ( key ) {
            if ( key in solutionLookup ) {
                solution[solutionLookup[key]].push([ deadEnds[i], prevKey ]);
                break;
            }
            prevKey= key;
            key= lookup[key][3];
        }
    }

    var end= solution.length / 10;

    var DOOR_MAX_POS= end;
    var DOOR_MIN_POS= end * 2;
    var KEY_MIN_POS= end;

    // FIXME: Find sane formula
    var doorsMake= Math.floor(Math.pow(mazeWidth * mazeHeight, .45) * .5);

    var _makeDoorKey= function( doorKey, ix ) {
        var keyKey;
        var entryKeyKey;
        var ix1= random(KEY_MIN_POS, ix);
        while ( ix1 < ix ) {
            if ( solution[ix1].length > 1 ) {
                var deadEndInfo= solution[ix1][random(1, solution[ix1].length)];
                if ( !(deadEndInfo[0] in items) ) {
                    keyKey= deadEndInfo[0];
                    entryKeyKey= deadEndInfo[1];
                    break;
                }
            }
            ix1++;
        }
        if ( keyKey !== undefined ) {
            doorsMake--;
            items[doorKey]= { type: DOOR, color: doorsMake };
            items[keyKey]= { type: KEY, color: doorsMake };

            // 50% chance to place a key at start of junction to block current
            if ( doorsMake > 0 && entryKeyKey && Math.random() > .5 ) {
                _makeDoorKey(entryKeyKey, ix1);
            }
        }
    };

    for ( var i= doorsMake * 3; i > 0 && doorsMake > 0; i-- ) {
        var doorKey= undefined;
        var ix= random(DOOR_MIN_POS, solution.length - DOOR_MAX_POS);
        while ( ix >= DOOR_MIN_POS ) {
            if ( solution[ix].length == 1 && !(solution[ix] in items) ) {
                doorKey= solution[ix][0];
                break;
            }
            ix--;
        }
        if ( doorKey !== undefined ) {
            _makeDoorKey(doorKey, ix);
        }
    }

    // console.table(lookup);
    // console.table(solution);
    // console.log(solutionLookup);
    // console.table(items);
    // console.log(deadEnds);
    // console.table(solution);
};

var genMonsters= function() {

    monsters= [];

    var monster= {
        x: pxPlayerX,
        y: pxPlayerY,
        projX: 0,
        prosY: 0,
        atTarget: 0,
    };

    monsters.push(monster);
};

var genMaze= function() {

    pxMazeWidth= pxTileWidth * mazeWidth;
    pxMazeHeight= pxTileHeight * mazeHeight;

    for ( var y= 0; y <= mazeHeight + 1; y++ ) {
        maze[y]= [];
    }

    for ( var y= 1; y <= mazeHeight; y += 2 ) {
        for ( var x= 1; x <= mazeWidth; x += 2 ) {
            maze[y][x]= CALC;
            maze[y][x + 1]= WALL;
            maze[y + 1][x]= WALL;
            maze[y + 1][x + 1]= WALL;
        }
    }

    for ( var y= 0; y <= mazeHeight + 1; y++ ) {
        maze[y][0]= FRAME;
        maze[y][mazeWidth + 1]= FRAME;
    }

    for ( var x= 1; x <= mazeWidth; x++ ) {
        maze[0][x]= FRAME;
        maze[mazeHeight + 1][x]= FRAME;
    }

    // Slow, horrible and naive. Ok for now...

    var floor= FLOOR_CALC;

    while ( true ) {

        var sample= [];
        for ( var y= 1; y <= mazeHeight; y += 2 ) {
            for ( var x= 1; x <= mazeWidth; x += 2 ) {
                if ( maze[y][x] === CALC ) sample.push([ x, y ]);
            }
        }
        if ( sample.length === 0 ) break;

        var retry= true;
        while ( retry ) {
            retry= false;

            var pos= sample[random(0, sample.length)];
            var posX= pos[0];
            var posY= pos[1];

            while ( maze[posY][posX] === CALC ) {
                maze[posY][posX]= floor;

                var dir= random(0, 4);

                // IDEE: bei i == 3 bzw == 2 werden wirds wiggliger
                var i_max= floor === FLOOR_CALC ? 4 : 2;
                for ( var i= 0; i < i_max; i++ ) {
                    var wallPosX= posX + dirs[dir][0];
                    var wallPosY= posY + dirs[dir][1];
                    if ( maze[wallPosY][wallPosX] === WALL ) {
                        var floorPosX= posX + dirs[dir][0] * 2;
                        var floorPosY= posY + dirs[dir][1] * 2;
                        if ( maze[floorPosY][floorPosX] !== floor ) {
                            maze[wallPosY][wallPosX]= floor;
                            posX += dirs[dir][0] * 2;
                            posY += dirs[dir][1] * 2;
                            break;
                        }
                    }
                    dir= (dir + 1) & 3;
                }
                if ( i >= i_max && floor > FLOOR_CALC ) {
                    for ( var y= 1; y <= mazeHeight; y += 2 ) {
                        for ( var x= 1; x <= mazeWidth; x += 2 ) {
                            if ( maze[y][x] === floor ) maze[y][x]= CALC;
                            if ( maze[y][x + 1] === floor ) maze[y][x + 1]= WALL;
                            if ( maze[y + 1][x] === floor ) maze[y + 1][x]= WALL;
                        }
                    }
                    retry= true;
                    break;
                }
            }
        }

        floor++;
    }


    // Find most distant cell
    var dists_= calcDistances(1,1);
    var startPos= dists_.lookup[dists_.maxDistanceKey];

    // Take the most distant cell and recalculate distances
    dists= calcDistances(startPos[0], startPos[1]);

// console.log(startPos);
// console.table(dists.byDistance);

    // Set maze floor data
    for ( var key in dists.lookup ) {
        var pos= dists.lookup[key];
        maze[pos[1]][pos[0]]= FLOOR + pos[2];
    }

    pxPlayerX= (startPos[0] - .5) * pxTileWidth;
    pxPlayerY= (startPos[1] - .5) * pxTileHeight;

    genItems();
    genMonsters();

    // console.table(maze);
};


// =============================================================================
//  Projection
// =============================================================================

// Static, to reduce GCs
var projX= [];
var projY= [];

var playerProjX;
var playerProjY;

var calcTileProj= function( pos, proj, p ) {

    var PI_2= Math.PI / 2;

    var pxTargetSize= p.pxTargetSize;
    var pxTileSize= p.pxTileSize;
    var border= p.border;
    var mazeSize= p.mazeSize;

    var pxBorder= border * pxTileSize;
    var pxMazeSize= pxTileSize * mazeSize;
    var pxMazeMove= pxTargetSize - pxMazeSize;
    if ( pxMazeMove > 0 ) pxMazeMove= 0;

    var pxTile0= pxMazeMove * pos / pxMazeSize;
    if ( pxMazeSize < pxTargetSize ) {
        pxTile0 += (pxTargetSize - pxMazeSize) / 2;
        pxTargetSize= pxTile0 + pxMazeSize;
    }

    var pxTileN= pxTile0 + pxMazeSize;

    var borderTile0= -1;
    var borderTile1= mazeSize;

    var pxTile= pxTile0;

    // <= !! Ein zusaetzlicher Wert wird noch benoetigt
    for ( var tile= 0; tile <= mazeSize; tile++ ) {

        if ( pxTile < pxBorder ) {
            borderTile0= tile;

            var fTile= (pxTile - pxTile0) / (pxBorder - pxTile0);
            proj[tile]= (1 - Math.sin(PI_2 + PI_2 * fTile)) * pxBorder;
        }
        else if ( pxTile >= pxTargetSize - pxBorder ) {
            if ( borderTile1 == mazeSize ) borderTile1= tile;

            var fTile= (pxTile - pxTileN) / (pxTargetSize - pxBorder - pxTileN);
            proj[tile]= pxTargetSize - (1 - Math.sin(PI_2 + PI_2 * fTile)) * pxBorder;
        }
        else {
            proj[tile]= pxTile;
        }

        pxTile += pxTileSize;
    }

    // Zu breite Tiles abschmaelern (Passiert durch Sinus)
    for ( ; borderTile0 >= 0; borderTile0-- ) {
        if ( proj[borderTile0 + 1] - proj[borderTile0] > pxTileSize ) {
            proj[borderTile0]= proj[borderTile0 + 1] - pxTileSize;
        }
    }

    for ( ; borderTile1 < mazeSize; borderTile1++ ) {
        if ( proj[borderTile1] - proj[borderTile1 - 1] > pxTileSize ) {
            proj[borderTile1]= proj[borderTile1 - 1] + pxTileSize;
        }
    }
};

var proj= function( x, y ) {
    var mazeX= Math.floor(x / pxTileWidth);
    var mazeY= Math.floor(y / pxTileHeight);
    var fracX= (x % pxTileWidth) / pxTileWidth;
    var fracY= (y % pxTileHeight) / pxTileHeight;
    return [ projX[mazeX] + (projX[mazeX + 1] - projX[mazeX]) * fracX
           , projY[mazeY] + (projY[mazeY + 1] - projY[mazeY]) * fracY ];
};

// TODO: Optimieren falls oefter benoetigt
var invProj= function( x, y ) {
    for ( var xi= projX.length - 2; xi >= 0; xi-- ) {
        if ( x >= projX[xi] ) {
            for ( var yi= projY.length - 2; yi >= 0; yi-- ) {
                if ( y >= projY[yi] ) {
                    return [ (xi + (x - projX[xi]) / (projX[xi + 1] - projX[xi])) * pxTileWidth
                           , (yi + (y - projY[yi]) / (projY[yi + 1] - projY[yi])) * pxTileHeight ];
                }
            }
            return;
        }
    }
};

var calcProjs= function() {

    calcTileProj(pxPlayerX, projX, {
        pxTargetSize: cWidth,
        pxTileSize: pxTileWidth,
        border: borderX,
        mazeSize: mazeWidth,
    });

    calcTileProj(pxPlayerY, projY, {
        pxTargetSize: cHeight,
        pxTileSize: pxTileHeight,
        border: borderY,
        mazeSize: mazeHeight,
    });

/*
    var mazeX= Math.floor(pxPlayerX / pxTileWidth);
    var mazeY= Math.floor(pxPlayerY / pxTileHeight);
    var dists= calcDistances(mazeX + 1, mazeY + 1);

    // Set maze floor data
    for ( var key in dists.lookup ) {
        var pos= dists.lookup[key];
        maze[pos[1]][pos[0]]= pos[2];
    }
*/

    var playerProj= proj(pxPlayerX, pxPlayerY);
    playerProjX= playerProj[0];
    playerProjY= playerProj[1];

    for ( var i= 0; i < monsters.length; i++ ) {
        var monsterProj= proj(monsters[i].x, monsters[i].y);
        monsters[i].projX= monsterProj[0];
        monsters[i].projY= monsterProj[1];
    }
};


// =============================================================================
//  Sprites
// =============================================================================

var spritesImage;
var shadowsImage;
var spriteCanvas= document.createElement('canvas');
// spriteCanvas.width= 128;
// spriteCanvas.height= 128;
var spriteContext= spriteCanvas.getContext('2d');

var cachedRgbs= [];

var getRgb= function( color ) {
    if ( !(color in cachedRgbs) ) {
        spriteContext.fillStyle= 'hsl(' + (color * 40) + ',100%,60%)';
        spriteContext.fillRect(0, 0, 1, 1);
        var rgba= spriteContext.getImageData(0, 0, 1, 1).data;
        cachedRgbs[color]= [ rgba[0], rgba[1], rgba[2] ];
    }
    return cachedRgbs[color];
}

var loadImage= function( url, cb ) {
    var image= new Image();
    image.src= url;
    image.onload= function() {
        image.onload= undefined;
        cb(image);
    };
}

var loadSprites= function( cb ) {
    loadImage('sprites.png', function( image ) {
        spritesImage= image;
        loadImage('shadows.png', function( image ) {
            shadowsImage= image;
            cb();
        });
    });
};

var cachedSpriteImages= [];

var _getColoredSpriteImage= function( x, y, color, withShadow ) {
    x *= 128;
    y *= 128;

    var width= pxTileWidth;
    var height= pxTileHeight;

    var key= x + ':' + y + ':' + width + ':' + height + ':' + color;
    if ( !(key in cachedSpriteImages) ) {

        var rgb= getRgb(color);

        spriteCanvas.width= width;
        spriteCanvas.height= width;
        spriteContext.drawImage(spritesImage, x, y, 128, 128, 0, 0, width, height);
        var imageData= spriteContext.getImageData(0, 0, width, height);
        var rgba= imageData.data;
        for ( var i= width * height * 4 - 4; i >= 0; i -= 4 ) {
            if ( rgba[i] === 0 && rgba[i + 3] !== 0 ) {
                rgba[i]= rgb[0];
                rgba[i + 1]= rgb[1];
                rgba[i + 2]= rgb[2];
            }
        }
        spriteContext.putImageData(imageData, 0, 0);

        if ( withShadow ) {
            spriteContext.drawImage(shadowsImage, x, y, 128, 128, 0, 0, width, height);
        }

        var image= new Image();
        image.src = spriteCanvas.toDataURL("image/png");
        cachedSpriteImages[key]= image;
    }

    return cachedSpriteImages[key];
}

var getSpriteImage= function( type, color ) {
    if ( type === KEY ) {
        return _getColoredSpriteImage(0, 0, color, true);
    }
};


// =============================================================================
//  Draw Canvas
// =============================================================================

var drawRect= function( x, y, w, h, hue ) {
    c.fillStyle= 'hsl(' + hue + ',100%,60%)';
    c.fillRect(x - w / 2, y - h / 2, w, h);
};

var drawMaze= function() {
    var c_= c; // Localize

    for ( var mazeY= 0; mazeY < mazeHeight; mazeY++ ) {
        for ( var mazeX= 0; mazeX < mazeWidth; mazeX++ ) {

            var px0= projX[mazeX];
            var px1= projX[mazeX + 1]
            var py0= projY[mazeY];
            var py1= projY[mazeY + 1]

            var content= maze[mazeY + 1][mazeX + 1];

            if ( content == WALL ) {
                // c_.fillStyle = 'rgb(' + Math.floor(255 * mazeX / mazeWidth) + ',' + (((mazeX + mazeY) & 1) ? 100 : 0) + ',0)';
                c_.fillStyle = 'rgb(20,100,0)';
            }
            else if ( content >= FLOOR ) {
                c_.fillStyle = 'hsl(10,50%,' + (80 - content + FLOOR) +'%)';
            }
            else {
                c_.fillStyle = 'rgb(0,0,0)';
            }
            c_.fillRect(px0, py0, px1 - px0, py1 - py0);

            var key= (mazeX + 1) + ':' + (mazeY + 1);
            if ( key in items ) {

                if ( items[key].type == KEY ) {

                    var spriteImage= getSpriteImage(KEY, items[key].color);

                    c.drawImage(spriteImage, 0, 0, pxTileWidth, pxTileHeight, px0, py0, px1 - px0, py1 - py0);
                    continue;
                }

                var w= 10, h= 10;
                if ( items[key].type == DOOR ) w= 40, h= 40; else w= 20;
                drawRect((px0 + px1) / 2, (py0 + py1) / 2, w, h, items[key].color * 40);
            }
        }
    }
}

var drawPlayer= function() {
    drawRect(playerProjX, playerProjY, pxPlayerWidth, pxPlayerHeight, 20);
};

var drawMonsters= function() {
    for ( var i= 0; i < monsters.length; i++ ) {
        drawRect(monsters[i].projX, monsters[i].projY, 40, 10, 200);
    }
};

var redraw= function() {
    calcProjs();

    c.fillStyle = 'rgb(0,0,0)';
    c.fillRect(0, 0, cWidth, cHeight);

    drawMaze();
    drawPlayer();
    drawMonsters();
};

var lastTimestamp;
var step= function( timestamp ) {
    if ( !lastTimestamp ) lastTimestamp= timestamp;
    var duration= timestamp - lastTimestamp;
    if ( duration >= 40 ) {

        lastTimestamp= timestamp;

        if ( DEBUG ) document.getElementById('debug').innerHTML= 1000 / duration;

        redraw();
    }
    window.requestAnimationFrame(step);
};

var resizeCanvas= function() {
    canvas.width= cWidth= window.innerWidth;
    canvas.height= cHeight= window.innerHeight;
    redraw();
};


// =============================================================================
//  Mouse
// =============================================================================

var MOUSE_CLICK_DELAY= 300;

var mousePress;
var mousePressTimestamp;
var playerIsMoving;

var onMouseMove= function( e ) {
    if ( e.changedTouches && e.changedTouches.length > 0 ) {
        mouseX= e.changedTouches[0].clientX;
        mouseY= e.changedTouches[0].clientY;
        return;
    }
    mouseX= e.clientX;
    mouseY= e.clientY;
};

var onMouseDown= function( e ) {
    onMouseMove(e);
    mousePressTimestamp= e.timeStamp;
    playerIsMoving= undefined;
}

var onMouseUp= function( e ) {
    if ( e.timeStamp - mousePressTimestamp < MOUSE_CLICK_DELAY ) {
        console.log("click", e);
        // click;
    }
    mousePressTimestamp= undefined;
    if ( e.cancelable ) e.preventDefault();
};


// =============================================================================
//  Move player
// =============================================================================

//  1 2    walls:
//  8 4    On which sides does player collide -> Index into wallActions
//
//    1    wallActions:
//  8   2  Which position must be corrected
//    4    E.g: Walls at 2 + 4 + 8
//              ==> walls == 14
//              ==> wallAction[walls] == 12
//              ==> Correct left (8) and bottom (4)
//         wallAction for e.g. walls == 1 depend on player's heading

var wallActions= [
    [ 0, 1, 1, 1, 4, 0, 2, 3, 4, 8, 0, 9, 4, 12, 6, 0 ],        // horizontal movement
    [ 0, 8, 2, 1, 2, 0, 2, 3, 8, 8, 0, 9, 4, 12, 6, 0 ],        // vertical movement
];

var direction= 0;  // horizontal movement

var __movePlayer= function( pxPlayerX_, pxPlayerY_, result ) {

    var mazeX0= Math.floor((pxPlayerX_ - pxPlayerWidth / 2) / pxTileWidth);
    var mazeY0= Math.floor((pxPlayerY_ - pxPlayerHeight / 2) / pxTileHeight);
    var mazeX1= Math.floor((pxPlayerX_ + pxPlayerWidth / 2) / pxTileWidth);
    var mazeY1= Math.floor((pxPlayerY_ + pxPlayerHeight / 2) / pxTileHeight);

    var walls00= maze[mazeY0 + 1][mazeX0 + 1] < FLOOR ? 1 : 0;
    var walls01= maze[mazeY0 + 1][mazeX1 + 1] < FLOOR ? 2 : 0;
    var walls11= maze[mazeY1 + 1][mazeX1 + 1] < FLOOR ? 4 : 0;
    var walls10= maze[mazeY1 + 1][mazeX0 + 1] < FLOOR ? 8 : 0;

    var walls= walls00 + walls01 + walls10 + walls11;
    if ( walls ) {
        var action= wallActions[direction][walls];
        if ( action === 0 ) return;

        if ( action & 1 ) pxPlayerY_= mazeY1 * pxTileHeight + pxPlayerHeight / 2;
        if ( action & 2 ) pxPlayerX_= mazeX0 * pxTileWidth + pxTileWidth - pxPlayerWidth / 2;
        if ( action & 4 ) pxPlayerY_= mazeY0 * pxTileHeight + pxTileHeight - pxPlayerHeight / 2;
        if ( action & 8 ) pxPlayerX_= mazeX1 * pxTileWidth + pxPlayerWidth / 2;
    }

    result[0]= pxPlayerX_;
    result[1]= pxPlayerY_;
};

var pxDirectionPlayerX= 0;
var pxDirectionPlayerY= 0;

var _movePlayerResult= [ 0, 0 ];
var _movePlayer= function( pxPlayerX_, pxPlayerY_ ) {
    __movePlayer(pxPlayerX_, pxPlayerY_, _movePlayerResult);
    var pxPlayerX__= _movePlayerResult[0];
    var pxPlayerY__= _movePlayerResult[1];

    var mazeX= Math.floor(pxPlayerX__ / pxTileWidth);
    var mazeY= Math.floor(pxPlayerY__ / pxTileHeight);

    // TODO: items pruefen

    var key= (mazeX + 1) + ':' + (mazeY + 1);
    if ( key in items ) {
        console.log(items[key]);

        if ( items[key].type === KEY ) {
            console.log("KEY!");
            
        }
        if ( items[key].type === DOOR ) {
            console.log("DOOR!");
            
        }
    }

    // FIXME: 150 abhaengig von Tile-Groesse?
    if ( (pxDirectionPlayerX - pxPlayerX_) * (pxDirectionPlayerX - pxPlayerX_) + (pxDirectionPlayerY - pxPlayerY_) * (pxDirectionPlayerY - pxPlayerY_) > 150 ) {
        direction= Math.abs(pxPlayerX_ - pxPlayerX) > Math.abs(pxPlayerY_ - pxPlayerY) ? 0 : 1;
        pxDirectionPlayerX= pxPlayerX_;
        pxDirectionPlayerY= pxPlayerY_;
    }

    pxPlayerX= pxPlayerX__;
    pxPlayerY= pxPlayerY__;
};

var movePlayer= function( playerSpeed ) {
    if ( playerProjX === undefined ) return;
    if ( mousePressTimestamp === undefined ) return;
    if ( mousePressTimestamp < MOUSE_CLICK_DELAY ) return;

    var dx= mouseX - playerProjX;
    var dy= mouseY - playerProjY;
    var dist= dx * dx + dy * dy;

    // Min. 20px (20^2)
    if ( dist < 400 ) {
        if ( !playerIsMoving ) return;

        var view= invProj(mouseX, mouseY);

        // mouseX/mouseY may be out of range
        if ( view === undefined ) return;

        _movePlayer(view[0], view[1]);
        return;
    }

    playerIsMoving= true;

    var alpha= Math.atan2(dx, dy);
    _movePlayer(pxPlayerX + Math.sin(alpha) * cWidth * playerSpeed,
                pxPlayerY + Math.cos(alpha) * cHeight * playerSpeed);
};


// =============================================================================
//  Move monsters
// =============================================================================

var moveMonster= function( monster, monsterSpeed ) {

// console.log(monster);

    if ( monster.atTarget === 0 ) {
        var mazeX= Math.floor(monster.x / pxTileWidth);
        var mazeY= Math.floor(monster.y / pxTileHeight);
        var dir= random(0, 4);
        for ( var i= 0; i < 4; i++ ) {
            var mazeX1= mazeX + dirs[dir][0];
            var mazeY1= mazeY + dirs[dir][1];
            if ( maze[mazeY1 + 1][mazeX1 + 1] >= FLOOR ) {
                monster.targetX= (mazeX1 + .5 + randomf(-.2, .2)) * pxTileWidth;
                monster.targetY= (mazeY1 + .5 + randomf(-.3, .3)) * pxTileHeight;
                monster.atTarget= 3;
                return;
            }
            dir= (dir + 1) & 3;
        }

        // Monster is stuck!
        return;
    }

    var alpha= Math.atan2(monster.targetX - monster.x, monster.targetY - monster.y);

// console.log(dx, dy);

    if ( monster.atTarget & 1 ) {
        var dx= Math.sin(alpha) * cWidth * monsterSpeed;
        if ( Math.abs(monster.x + dx - monster.targetX) <= dx ) {
            monster.x= monster.targetX;
            monster.atTarget &= ~1;
        }
        else {
            monster.x += dx;
        }
    }
    if ( monster.atTarget & 2 ) {
        var dy= Math.cos(alpha) * cHeight * monsterSpeed;
        if ( Math.abs(monster.y + dy - monster.targetY) <= dy ) {
            monster.y= monster.targetY;
            monster.atTarget &= ~2;
        }
        else {
            monster.y += dy;
        }
    }
};

var moveMonsters= function( monsterSpeed ) {
    for ( var i= 0; i < monsters.length; i++ ) {
        moveMonster(monsters[i], monsterSpeed);
    }
};


// =============================================================================
//  Game Logic
// =============================================================================

var GAME_SPEED= 50;

var gameLogic= function() {
    movePlayer(GAME_SPEED / 3000);
    moveMonsters(GAME_SPEED / 10000);
};


// =============================================================================
//  Init
// =============================================================================

var init= function() {

    genMaze();

    canvas= document.getElementById('stage');
    c= canvas.getContext('2d');

    window.addEventListener('resize', resizeCanvas, false);
    resizeCanvas();

    window.addEventListener('touchstart', onMouseDown, false);
    window.addEventListener('mousedown', onMouseDown, false);
    window.addEventListener('touchmove', onMouseMove, false);
    window.addEventListener('mousemove', onMouseMove, false);
    window.addEventListener('touchend', onMouseUp, false);
    window.addEventListener('mouseup', onMouseUp, false);

    window.requestAnimationFrame(step);
    setInterval(gameLogic, GAME_SPEED);
};

window.addEventListener('load', function() {
    loadSprites(init);
});

})();
</script>

<div id="debug"></div>
<canvas id="stage"></canvas>
