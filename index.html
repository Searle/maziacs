<title>Maziacs</title>

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

<style>
    body {
        margin: 0;
        height: 100%;
        overflow: hidden;
    }
    #stage {
        cursor: default;
        display: block;
        width: 100%;
        height: 100%;
    }
    #debug {
        position: absolute;
        top: -1px;
        right: -1px;
        background-color: white;
        border: 1px solid #000;
        width: 100px;
        height: 50px;
        overflow: hidden;
    }
</style>

<script src="sprint-master/sprint.js"></script>

<script>
(function() {

"use strict";

var mouseX;
var mouseY;

var canvas;
var c;
var cWidth;
var cHeight;

var maze= [];
var mazeWidth= 15;
var mazeHeight= 15;

var dists;
var items;

var pxMazeWidth;
var pxMazeHeight;

var pxViewX;
var pxViewY;

var pxTileWidth= 48;
var pxTileHeight= 48;
var pxTileWidth2= pxTileWidth / 2;
var pxTileHeight2= pxTileHeight / 2;

var pxPlayerWidth= 20;
var pxPlayerHeight= 20;

var borderX= 2;
var borderY= 2;

var DOOR= -5;
var KEY= -4;
var CALC= -3;
var FRAME= -2;
var WALL= -1;
var FLOOR= 0;
var FLOOR_CALC= 0;

var dirs= [ [ 0, -1 ], [ 1, 0 ], [ 0, 1 ], [ -1, 0 ] ];


// =============================================================================
//  Calculate distances from point in maze
// =============================================================================

var calcDistances= function( startPosX, startPosY ) {

    var distance= 0;
    var key= startPosX + ':' + startPosY;
    var queue= [ [ key, startPosX, startPosY, distance ] ];
    var maxDistanceKey= key;
    var maxDistance= distance;

    var lookup= {};
    lookup[key]= [ startPosX, startPosY, distance, undefined ];

    var byDistance= [ [ key ] ];
    var deadEnds= [];

    while ( queue.length > 0 ) {
        var pos= queue.pop();
        var key= pos[0];
        var posX= pos[1];
        var posY= pos[2];
        var distance= pos[3] + 1;

        var isDeadEnd= true;
        for ( var dir= 0; dir < 4; dir++ ) {
            var nextPosX= posX + dirs[dir][0];
            var nextPosY= posY + dirs[dir][1];
            if ( maze[nextPosY][nextPosX] < FLOOR_CALC ) continue;

            var nextKey= nextPosX + ':' + nextPosY;
            if ( nextKey in lookup ) continue;

            lookup[nextKey]= [ nextPosX, nextPosY, distance, key ];

            // Children merken, falls benoetigt
            // lookup[key].push(nextKey);

            if ( byDistance.length - 1 < distance ) {
                byDistance[distance]= [ nextKey ];
            }
            else {
                byDistance[distance].push(nextKey);
            }

            queue.push([ nextKey, nextPosX, nextPosY, distance ]);
            isDeadEnd= false;

            if ( distance > maxDistance ) {
                maxDistanceKey= nextKey;
                maxDistance= distance;
            }
        }
        if ( isDeadEnd ) {
            deadEnds.push(key);
        }
    }

    return {
        lookup: lookup,
        maxDistanceKey: maxDistanceKey,
        maxDistance: maxDistance,
        byDistance: byDistance,
        deadEnds: deadEnds,
    };
};

var genItems= function() {
    items= {};

    var lookup= dists.lookup;
    var maxDistance= dists.maxDistance;
    var maxDistanceKey= dists.maxDistanceKey;
    var deadEnds= dists.deadEnds;

    var solution= [];
    var solutionLookup= {};

    var key= maxDistanceKey;
    while ( key ) {
        solutionLookup[key]= maxDistance - solution.length; // == lookup[key][2]
        solution.unshift([ key ]);
        key= lookup[key][3];
    }

    for ( var i= 0; i < deadEnds.length; i++ ) {
        var key= deadEnds[i];
        if ( key === maxDistanceKey ) continue;

        var prevKey= undefined;
        while ( key ) {
            if ( key in solutionLookup ) {
                solution[solutionLookup[key]].push([ deadEnds[i], prevKey ]);
                break;
            }
            prevKey= key;
            key= lookup[key][3];
        }
    }

    var end= solution.length / 10;

    var DOOR_MAX_POS= end;
    var DOOR_MIN_POS= end * 2;
    var KEY_MIN_POS= end;

    // FIXME: Find sane formula
    var doorsMake= Math.floor(Math.pow(mazeWidth * mazeHeight, .45) * .5);

    var _makeDoorKey= function( doorKey, ix ) {
        var keyKey;
        var entryKeyKey;
        var ix1= Math.floor(Math.random() * (ix - KEY_MIN_POS) + KEY_MIN_POS);
        while ( ix1 < ix ) {
            if ( solution[ix1].length > 1 ) {
                var deadEndInfo= solution[ix1][Math.floor(Math.random() * (solution[ix1].length - 1)) + 1];
                if ( !(deadEndInfo[0] in items) ) {
                    keyKey= deadEndInfo[0];
                    entryKeyKey= deadEndInfo[1];
                    break;
                }
            }
            ix1++;
        }
        if ( keyKey !== undefined ) {
            doorsMake--;
            items[doorKey]= { type: DOOR, color: doorsMake };
            items[keyKey]= { type: KEY, color: doorsMake };

            // 50% chance to place a key at start of junction to block current
            if ( doorsMake > 0 && entryKeyKey && Math.random() > .5 ) {
                _makeDoorKey(entryKeyKey, ix1);
            }
        }
    };

    for ( var i= doorsMake * 3; i > 0 && doorsMake > 0; i-- ) {
        var doorKey= undefined;
        var ix= Math.floor(Math.random() * (solution.length - (DOOR_MAX_POS + DOOR_MIN_POS)) + DOOR_MIN_POS);
        while ( ix >= DOOR_MIN_POS ) {
            if ( solution[ix].length == 1 && !(solution[ix] in items) ) {
                doorKey= solution[ix][0];
                break;
            }
            ix--;
        }
        if ( doorKey !== undefined ) {
            _makeDoorKey(doorKey, ix);
        }
    }

    // console.table(lookup);
    // console.table(solution);
    // console.log(solutionLookup);
    // console.table(items);
    // console.log(deadEnds);
    // console.table(solution);
}


// =============================================================================
//  Generate new maze
// =============================================================================

var XX_genItems= function() {

    items= {};

    var byDistance= dists.byDistance;
    var distance= byDistance.length;

    var step= Math.floor(distance / 10);

    // 3 doors + 3 keys
    for ( var i= 0; i < 3; i++ ) {
        var keys= [ undefined, undefined ];

        distance= byDistance.length - i * step;

        // k: 0=door, 1=key
        for ( var k= 0; k < 2; k++ ) {

            distance= Math.floor(distance * .5 + Math.random() * distance * .5);

            // distance -= step;

            while ( distance > 10 && keys[k] === undefined ) {

                var check;
                if ( k == 0 ) {
                    check= [ byDistance[distance][0] ];
                }
                else {
                    check= byDistance[distance];
                }

                for ( var j= check.length - 1; j >= 0; j-- ) {
                    if ( !(check[j] in items) ) {
                        keys[k]= check[j];
                        break;
                    }
                }
                distance--;
            }
        }

        if ( keys[0] && keys[1] ) {
            items[keys[0]]= { type: DOOR, color: i };
            items[keys[1]]= { type: KEY, color: i };
        }
    }

    console.table(items);
};

var genMaze= function() {

    pxMazeWidth= pxTileWidth * mazeWidth;
    pxMazeHeight= pxTileHeight * mazeHeight;

    for ( var y= 0; y <= mazeHeight + 1; y++ ) {
        maze[y]= [];
    }

    for ( var y= 1; y <= mazeHeight; y += 2 ) {
        for ( var x= 1; x <= mazeWidth; x += 2 ) {
            maze[y][x]= CALC;
            maze[y][x + 1]= WALL;
            maze[y + 1][x]= WALL;
            maze[y + 1][x + 1]= WALL;
        }
    }

    for ( var y= 0; y <= mazeHeight + 1; y++ ) {
        maze[y][0]= FRAME;
        maze[y][mazeWidth + 1]= FRAME;
    }

    for ( var x= 1; x <= mazeWidth; x++ ) {
        maze[0][x]= FRAME;
        maze[mazeHeight + 1][x]= FRAME;
    }

    // Slow, horrible and naive. Ok for now...

    var floor= FLOOR_CALC;

    while ( true ) {

        var sample= [];
        for ( var y= 1; y <= mazeHeight; y += 2 ) {
            for ( var x= 1; x <= mazeWidth; x += 2 ) {
                if ( maze[y][x] === CALC ) sample.push([ x, y ]);
            }
        }
        if ( sample.length === 0 ) break;

        var retry= true;
        while ( retry ) {
            retry= false;

            var pos= sample[Math.floor(Math.random() * sample.length)];
            var posX= pos[0];
            var posY= pos[1];

            while ( maze[posY][posX] === CALC ) {
                maze[posY][posX]= floor;

                var dir= Math.floor(Math.random() * 4);

                // IDEE: bei i == 3 bzw == 2 werden wirds wiggliger
                var i_max= floor === FLOOR_CALC ? 4 : 2;
                for ( var i= 0; i < i_max; i++ ) {
                    var wallPosX= posX + dirs[dir][0];
                    var wallPosY= posY + dirs[dir][1];
                    if ( maze[wallPosY][wallPosX] === WALL ) {
                        var floorPosX= posX + dirs[dir][0] * 2;
                        var floorPosY= posY + dirs[dir][1] * 2;
                        if ( maze[floorPosY][floorPosX] !== floor ) {
                            maze[wallPosY][wallPosX]= floor;
                            posX += dirs[dir][0] * 2;
                            posY += dirs[dir][1] * 2;
                            break;
                        }
                    }
                    dir= (dir + 1) & 3;
                }
                if ( i >= i_max && floor > FLOOR_CALC ) {
                    for ( var y= 1; y <= mazeHeight; y += 2 ) {
                        for ( var x= 1; x <= mazeWidth; x += 2 ) {
                            if ( maze[y][x] === floor ) maze[y][x]= CALC;
                            if ( maze[y][x + 1] === floor ) maze[y][x + 1]= WALL;
                            if ( maze[y + 1][x] === floor ) maze[y + 1][x]= WALL;
                        }
                    }
                    retry= true;
                    break;
                }
            }
        }

        floor++;
    }


    // Find most distant cell
    var dists_= calcDistances(1,1);
    var startPos= dists_.lookup[dists_.maxDistanceKey];

    // Take the most distant cell and recalculate distances
    dists= calcDistances(startPos[0], startPos[1]);

// console.log(startPos);
// console.table(dists.byDistance);

    genItems();

    // Set maze floor data
    for ( var key in dists.lookup ) {
        var pos= dists.lookup[key];
        maze[pos[1]][pos[0]]= FLOOR + pos[2];
    }

    pxViewX= (startPos[0] - .5) * pxTileWidth;
    pxViewY= (startPos[1] - .5) * pxTileHeight;

    // console.table(maze);
}


// =============================================================================
//  Projection
// =============================================================================

// Static, to reduce GCs
var projX= [];
var projY= [];

var playerProjX;
var playerProjY;

var calcTileProj= function( pos, proj, p ) {

    var PI_2= Math.PI / 2;

    var pxTargetSize= p.pxTargetSize;
    var pxTileSize= p.pxTileSize;
    var border= p.border;
    var mazeSize= p.mazeSize;

    var pxBorder= border * pxTileSize;
    var pxMazeSize= pxTileSize * mazeSize;
    var pxMazeMove= pxTargetSize - pxMazeSize;
    if ( pxMazeMove > 0 ) pxMazeMove= 0;

    var pxTile0= pxMazeMove * pos / pxMazeSize;
    if ( pxMazeSize < pxTargetSize ) {
        pxTile0 += (pxTargetSize - pxMazeSize) / 2;
        pxTargetSize= pxTile0 + pxMazeSize;
    }

    var pxTileN= pxTile0 + pxMazeSize;

    var borderTile0= -1;
    var borderTile1= mazeSize;

    var pxTile= pxTile0;

    // <= !! Ein zusaetzlicher Wert wird noch benoetigt
    for ( var tile= 0; tile <= mazeSize; tile++ ) {

        if ( pxTile < pxBorder ) {
            borderTile0= tile;

            var fTile= (pxTile - pxTile0) / (pxBorder - pxTile0);
            proj[tile]= (1 - Math.sin(PI_2 + PI_2 * fTile)) * pxBorder;
        }
        else if ( pxTile >= pxTargetSize - pxBorder ) {
            if ( borderTile1 == mazeSize ) borderTile1= tile;

            var fTile= (pxTile - pxTileN) / (pxTargetSize - pxBorder - pxTileN);
            proj[tile]= pxTargetSize - (1 - Math.sin(PI_2 + PI_2 * fTile)) * pxBorder;
        }
        else {
            proj[tile]= pxTile;
        }

        pxTile += pxTileSize;
    }

    // Zu breite Tiles abschmaelern (Passiert durch Sinus)
    for ( ; borderTile0 >= 0; borderTile0-- ) {
        if ( proj[borderTile0 + 1] - proj[borderTile0] > pxTileSize ) {
            proj[borderTile0]= proj[borderTile0 + 1] - pxTileSize;
        }
    }

    for ( ; borderTile1 < mazeSize; borderTile1++ ) {
        if ( proj[borderTile1] - proj[borderTile1 - 1] > pxTileSize ) {
            proj[borderTile1]= proj[borderTile1 - 1] + pxTileSize;
        }
    }
};

var proj= function( x, y ) {
    var mazeX= Math.floor(x / pxTileWidth);
    var mazeY= Math.floor(y / pxTileHeight);
    var fracX= (x % pxTileWidth) / pxTileWidth;
    var fracY= (y % pxTileHeight) / pxTileHeight;
    return [ projX[mazeX] + (projX[mazeX + 1] - projX[mazeX]) * fracX
           , projY[mazeY] + (projY[mazeY + 1] - projY[mazeY]) * fracY ];
};

// TODO: Optimieren falls oefter benoetigt
var invProj= function( x, y ) {
    for ( var xi= projX.length - 2; xi >= 0; xi-- ) {
        if ( x >= projX[xi] ) {
            for ( var yi= projY.length - 2; yi >= 0; yi-- ) {
                if ( y >= projY[yi] ) {
                    return [ (xi + (x - projX[xi]) / (projX[xi + 1] - projX[xi])) * pxTileWidth
                           , (yi + (y - projY[yi]) / (projY[yi + 1] - projY[yi])) * pxTileHeight ];
                }
            }
            return;
        }
    }
};

var calcProjs= function() {

    calcTileProj(pxViewX, projX, {
        pxTargetSize: cWidth,
        pxTileSize: pxTileWidth,
        border: borderX,
        mazeSize: mazeWidth,
    });

    calcTileProj(pxViewY, projY, {
        pxTargetSize: cHeight,
        pxTileSize: pxTileHeight,
        border: borderY,
        mazeSize: mazeHeight,
    });

/*
    var mazeX= Math.floor(pxViewX / pxTileWidth);
    var mazeY= Math.floor(pxViewY / pxTileHeight);
    var dists= calcDistances(mazeX + 1, mazeY + 1);

    // Set maze floor data
    for ( var key in dists.lookup ) {
        var pos= dists.lookup[key];
        maze[pos[1]][pos[0]]= pos[2];
    }
*/

    var playerProj= proj(pxViewX, pxViewY);
    playerProjX= playerProj[0];
    playerProjY= playerProj[1];
};


// =============================================================================
//  Draw Canvas
// =============================================================================

var drawRect= function( x, y, w, h, hue ) {
    c.fillStyle= 'hsl(' + hue + ',100%,60%)';
    c.fillRect(x - w / 2, y - h / 2, w, h);
};

var drawMaze= function() {
    var c_= c; // Localize

    for ( var mazeY= 0; mazeY < mazeHeight; mazeY++ ) {
        for ( var mazeX= 0; mazeX < mazeWidth; mazeX++ ) {

            var px0= projX[mazeX];
            var px1= projX[mazeX + 1]
            var py0= projY[mazeY];
            var py1= projY[mazeY + 1]

            var content= maze[mazeY + 1][mazeX + 1];

            if ( content == WALL ) {
                // c_.fillStyle = 'rgb(' + Math.floor(255 * mazeX / mazeWidth) + ',' + (((mazeX + mazeY) & 1) ? 100 : 0) + ',0)';
                c_.fillStyle = 'rgb(20,100,0)';
            }
            else if ( content >= FLOOR ) {
                c_.fillStyle = 'hsl(10,50%,' + (content - FLOOR) +'%)';
            }
            else {
                c_.fillStyle = 'rgb(0,0,0)';
            }
            c_.fillRect(px0, py0, px1 - px0, py1 - py0);

            var key= (mazeX + 1) + ':' + (mazeY + 1);
            if ( key in items ) {
                var w= 10, h= 10;
                if ( items[key].type == DOOR ) w= 40, h= 40; else w= 20;
                drawRect((px0 + px1) / 2, (py0 + py1) / 2, w, h, items[key].color * 40);
            }
        }
    }
}

var drawPlayer= function() {
    drawRect(playerProjX, playerProjY, pxPlayerWidth, pxPlayerHeight, 20);
};

var redraw= function() {
    calcProjs();

    c.fillStyle = 'rgb(0,0,0)';
    c.fillRect(0, 0, cWidth, cHeight);

    drawMaze();
    drawPlayer();
};

var lastTimestamp;
var step= function( timestamp ) {
    if ( !lastTimestamp ) lastTimestamp= timestamp;
    var duration= timestamp - lastTimestamp;
    if ( duration >= 40 ) {

        lastTimestamp= timestamp;

        $('#debug').html(1000 / duration);

        redraw();
    }
    window.requestAnimationFrame(step);
};

window.requestAnimationFrame(step);

// setInterval(genMaze, 2000);

var resizeCanvas= function() {
    canvas.width= cWidth= window.innerWidth;
    canvas.height= cHeight= window.innerHeight;
    redraw();
};


// =============================================================================
//  Mouse
// =============================================================================

var MOUSE_CLICK_DELAY= 300;

var mousePress;
var mousePressTimestamp;
var playerIsMoving;

var onMouseMove= function( e ) {
    if ( e.changedTouches && e.changedTouches.length > 0 ) {
        mouseX= e.changedTouches[0].clientX;
        mouseY= e.changedTouches[0].clientY;
        return;
    }
    mouseX= e.clientX;
    mouseY= e.clientY;
};

var onMouseDown= function( e ) {
    onMouseMove(e);
    mousePressTimestamp= e.timeStamp;
    playerIsMoving= undefined;
}

var onMouseUp= function( e ) {
    if ( e.timeStamp - mousePressTimestamp < MOUSE_CLICK_DELAY ) {
        console.log("click", e);
        // click;
    }
    mousePressTimestamp= undefined;
    if ( e.cancelable ) e.preventDefault();
};


// =============================================================================
//  Game Logic
// =============================================================================

var GAME_SPEED= 50;
var PLAYER_SPEED= 3000 / GAME_SPEED;

//  1 2    walls:
//  8 4    On which sides does player collide -> Index into wallActions
//
//    1    wallActions:
//  8   2  Which position must be corrected
//    4    E.g: Walls at 2 + 4 + 8
//              ==> walls == 14
//              ==> wallAction[walls] == 12
//              ==> Correct left (8) and bottom (4)
//         wallAction for e.g. walls == 1 depend on player's heading

var wallActions= [
    [ 0, 1, 1, 1, 4, 0, 2, 3, 4, 8, 0, 9, 4, 12, 6, 0 ],        // horizontal movement
    [ 0, 8, 2, 1, 2, 0, 2, 3, 8, 8, 0, 9, 4, 12, 6, 0 ],        // vertical movement
];

var _movePlayer= function( pxViewX_, pxViewY_ ) {

    var pxViewX1;
    var pxViewY1;
    var mazeX;
    var mazeY= Math.floor(pxViewY / pxTileHeight);

    var mazeX0= Math.floor((pxViewX_ - pxPlayerWidth / 2) / pxTileWidth);
    var mazeY0= Math.floor((pxViewY_ - pxPlayerHeight / 2) / pxTileHeight);
    var mazeX1= Math.floor((pxViewX_ + pxPlayerWidth / 2) / pxTileWidth);
    var mazeY1= Math.floor((pxViewY_ + pxPlayerHeight / 2) / pxTileHeight);

    var walls00= maze[mazeY0 + 1][mazeX0 + 1] < FLOOR ? 1 : 0;
    var walls01= maze[mazeY0 + 1][mazeX1 + 1] < FLOOR ? 2 : 0;
    var walls11= maze[mazeY1 + 1][mazeX1 + 1] < FLOOR ? 4 : 0;
    var walls10= maze[mazeY1 + 1][mazeX0 + 1] < FLOOR ? 8 : 0;

    var walls= walls00 + walls01 + walls10 + walls11;
    if ( walls ) {
        var action= wallActions[Math.abs(pxViewX1 - pxViewX) > Math.abs(pxViewY1 - pxViewY) ? 0 : 1][walls];
        if ( action === 0 ) return;

        if ( action & 1 ) pxViewY_= mazeY1 * pxTileHeight + pxPlayerHeight / 2;
        if ( action & 2 ) pxViewX_= mazeX0 * pxTileWidth + pxTileWidth - pxPlayerWidth / 2;
        if ( action & 4 ) pxViewY_= mazeY0 * pxTileHeight + pxTileHeight - pxPlayerHeight / 2;
        if ( action & 8 ) pxViewX_= mazeX1 * pxTileWidth + pxPlayerWidth / 2;
    }

    pxViewX= pxViewX_;
    pxViewY= pxViewY_;
}

var movePlayer= function() {
    if ( playerProjX === undefined ) return;
    if ( mousePressTimestamp === undefined ) return;
    if ( mousePressTimestamp < MOUSE_CLICK_DELAY ) return;

    var dx= mouseX - playerProjX;
    var dy= mouseY - playerProjY;
    var dist= dx * dx + dy * dy;

    // Min. 20px (20^2)
    if ( dist < 400 ) {
        if ( playerIsMoving ) {
            var view= invProj(mouseX, mouseY);

            // mouseX/mouseY may be out of range
            if ( view !== undefined ) _movePlayer(view[0], view[1]);
        }
        return;
    }

    playerIsMoving= true;

    var alpha= Math.atan2(dx, dy);
    _movePlayer(pxViewX + Math.sin(alpha) * cWidth / PLAYER_SPEED,
                pxViewY + Math.cos(alpha) * cHeight / PLAYER_SPEED);
};

var gameLogic= function() {
    movePlayer();
}


// =============================================================================
//  Init
// =============================================================================

setInterval(gameLogic, GAME_SPEED);

var init= function() {

    genMaze();

    canvas= document.getElementById('stage');
    c= canvas.getContext('2d');

    window.addEventListener('resize', resizeCanvas, false);
    resizeCanvas();

    window.addEventListener('touchstart', onMouseDown, false);
    window.addEventListener('mousedown', onMouseDown, false);
    window.addEventListener('touchmove', onMouseMove, false);
    window.addEventListener('mousemove', onMouseMove, false);
    window.addEventListener('touchend', onMouseUp, false);
    window.addEventListener('mouseup', onMouseUp, false);
};

$(function() {
    init();

});

})();
</script>

<div id="debug"></div>
<canvas id="stage"></canvas>
