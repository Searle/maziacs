<style>
    body {
        margin: 0;
        height: 100%;
        overflow: hidden;
    }
    #stage {
        display: block;
        width: 100%;
        height: 100%;
    }
    #debug {
        position: absolute;
        top: -1px;
        right: -1px;
        background-color: white;
        border: 1px solid #000;
        width: 100px;
        height: 50px;
    }
</style>

<script src="sprint-master/sprint.js"></script>

<script>
(function() {

"use strict";

var mouseX;
var mouseY;

var canvas;
var c;
var cWidth;
var cHeight;

var maze= [];
var mazeWidth= 30;
var mazeHeight= 30;

var pxMazeWidth;
var pxMazeHeight;

var viewX;
var viewY;

var pxTileWidth= 48;
var pxTileHeight= 48;

var borderX= 2;
var borderY= 2;

var initMaze= function() {

    pxMazeWidth= pxTileWidth * mazeWidth;
    pxMazeHeight= pxTileHeight * mazeHeight;
    viewX= pxMazeWidth / 2;
    viewY= pxMazeHeight / 2;

    for ( var y= 0; y < mazeHeight; y++ ) {
        maze[y]= [];
        for ( var x= 0; x < mazeWidth; x++ ) {
            if ( Math.random() < .5 ) maze[y][x]= 1;
        }
    }

//     console.table(maze);
}

var d= 1;

var ofsX= .1;  // 0 .. 1
var ofyY= .5;


var calcTilePos= function( view, pos, p ) {

    var PI_2= Math.PI / 2;

    var pxTargetSize= p.pxTargetSize;
    var pxTileSize= p.pxTileSize;
    var border= p.border;
    var mazeSize= p.mazeSize;

    var pxBorder= border * pxTileSize;
    var pxMazeSize= pxTileSize * mazeSize;
    var pxMazeMove= pxTargetSize - pxMazeSize;

    if ( pxMazeMove > 0 ) pxMazeMove= 0;

    var pxTile0= pxMazeMove * view / pxMazeSize;
    var pxTileN= pxTile0 + pxMazeSize;

    var borderTile0= -1;
    var borderTile1= mazeSize;

    var pxTile= pxTile0;

    // <= !! Ein zusaetzlicher Wert wird noch benoetigt
    for ( var tile= 0; tile <= mazeSize; tile++ ) {

        if ( pxTile < pxBorder ) {
            borderTile0= tile;

            var fTile= (pxTile - pxTile0) / (pxBorder - pxTile0);
            pos[tile]= (1 - Math.sin(PI_2 + PI_2 * fTile)) * pxBorder;
        }
        else if ( pxTile >= pxTargetSize - pxBorder ) {
            if ( borderTile1 == mazeSize ) borderTile1= tile;

            var fTile= (pxTile - pxTileN) / (pxTargetSize - pxBorder - pxTileN);
            pos[tile]= pxTargetSize - (1 - Math.sin(PI_2 + PI_2 * fTile)) * pxBorder;
        }
        else {
            pos[tile]= pxTile;
        }

        pxTile += pxTileSize;
    }

    // Zu breite Tiles abschmaelern (Passiert durch Sinus)
    for ( ; borderTile0 >= 0; borderTile0-- ) {
        if ( pos[borderTile0 + 1] - pos[borderTile0] > pxTileSize ) {
            pos[borderTile0]= pos[borderTile0 + 1] - pxTileSize;
        }
    }

    for ( ; borderTile1 < mazeSize; borderTile1++ ) {
        if ( pos[borderTile1] - pos[borderTile1 - 1] > pxTileSize ) {
            pos[borderTile1]= pos[borderTile1 - 1] + pxTileSize;
        }
    }
}

// Wiederverwenden, um GC zu entlasten
var posXs= [];
var posYs= [];

var drawMaze= function() {
    var c_= c; // Localize

    calcTilePos(viewX, posXs, {
        pxTargetSize: cWidth,
        pxTileSize: pxTileWidth,
        border: borderX,
        mazeSize: mazeWidth,
    });

    calcTilePos(viewY, posYs, {
        pxTargetSize: cHeight,
        pxTileSize: pxTileHeight,
        border: borderY,
        mazeSize: mazeHeight,
    });

    c.clearRect(0, 0, cWidth, cHeight);

    for ( var y= 0; y < mazeHeight; y++ ) {
        for ( var x= 0; x < mazeWidth; x++ ) {

            var px0= posXs[x];
            var px1= posXs[x + 1]
            var py0= posYs[y];
            var py1= posYs[y + 1]

            if ( maze[y][x] ) {
                c_.fillStyle = 'rgb(' + Math.floor(255 * x / mazeWidth) + ',' + (((x + y) & 1) ? 100 : 0) + ',0)';
            }
            else {
                c_.fillStyle = 'rgb(255,255,255)';
            }
            c_.fillRect(px0, py0, px1 - px0, py1 - py0);
        }
    }
}

var lastTimestamp;
var step= function( timestamp ) {
    if ( !lastTimestamp ) lastTimestamp= timestamp;
    var duration= timestamp - lastTimestamp;
    if ( duration >= 40 ) {

        lastTimestamp= timestamp;

        $('#debug').html(1000 / duration);

        drawMaze();
    }
    window.requestAnimationFrame(step);
}

window.requestAnimationFrame(step);

// setInterval(initMaze, 2000);

var redraw= function() {
    c.strokeStyle = 'blue';
    c.lineWidth = '5';
    c.strokeRect(0, 0, cWidth, cHeight);

    drawMaze();
}

var resizeCanvas= function() {
    canvas.width= cWidth= window.innerWidth;
    canvas.height= cHeight= window.innerHeight;
    redraw();
}


// =============================================================================
//  Mouse
// =============================================================================

var MOUSE_CLICK_DELAY= 300;

var mousePress;
var mousePressTimestamp;

var onMouseMove= function( e ) {
    mouseX= e.clientX;
    mouseY= e.clientY;
};

var onMouseDown= function( e ) {
    mousePressTimestamp= e.timeStamp;
    onMouseMove(e);
}

var onMouseUp= function( e ) {
    if ( e.timeStamp - mousePressTimestamp < MOUSE_CLICK_DELAY ) {
        console.log("click", e);
        // click;
    }
    mousePressTimestamp= undefined;
}


// =============================================================================
//  Game Logic
// =============================================================================

var dirs= [
    [ 0, -1 ], [ -1, -1 ], [ -1, 0 ], [ -1, 1 ], [ 0, 1 ], [ 1, 1 ], [ 1, 0 ], [ 1, -1 ], [ 0, -1 ]
];

var GAME_SPEED= 50;
var PLAYER_SPEED= 1000 / GAME_SPEED;

var gameLogic= function() {
    if ( mousePressTimestamp !== undefined && mousePressTimestamp >= MOUSE_CLICK_DELAY ) {
        var dx= mouseX - cWidth / 2;
        var dy= mouseY - cHeight / 2;

//        console.log(dx, dy, Math.floor((Math.atan2(dx, dy) + Math.PI / 8) * 4 / Math.PI));
        var dirIndex= Math.floor((Math.atan2(dx, dy) + Math.PI / 8) * 4 / Math.PI) + 4;
        var dirX= dirs[dirIndex][0];
        var dirY= dirs[dirIndex][1];

        viewX += dirX * cWidth / PLAYER_SPEED;
        if ( viewX < 0 ) viewX= 0;
        else if ( viewX >= pxMazeWidth ) viewX= pxMazeWidth;
        viewY += dirY * cHeight / PLAYER_SPEED;
        if ( viewY < 0 ) viewY= 0;
        else if ( viewY >= pxMazeHeight ) viewY= pxMazeHeight;

        // console.log(dirs[dirIndex]);
    }
};


// =============================================================================
//  Init
// =============================================================================

setInterval(gameLogic, GAME_SPEED);

var init= function() {

    initMaze();

    canvas= document.getElementById('stage');
    c= canvas.getContext('2d');

    window.addEventListener('resize', resizeCanvas, false);
    resizeCanvas();

    window.addEventListener('mousemove', onMouseMove, false);
    window.addEventListener('mousedown', onMouseDown, false);
    window.addEventListener('mouseup', onMouseUp, false);
}

$(function() {
    init();

});

})();
</script>

<div id="debug"></div>
<canvas id="stage"></canvas>
