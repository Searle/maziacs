<style>
    body {
        margin: 0;
        height: 100%;
        overflow: hidden;
    }
    #stage {
        display: block;
        width: 100%;
        height: 100%;
    }
    #debug {
        position: absolute;
        top: -1px;
        right: -1px;
        background-color: white;
        border: 1px solid #000;
        width: 100px;
        height: 50px;
    }
</style>

<script src="sprint-master/sprint.js"></script>

<script>
(function() {

"use strict";

var mouseX;
var mouseY;

var canvas;
var c;
var cWidth;
var cHeight;

var maze= [];
var mazeWidth= 100;
var mazeHeight= 30;

var initMaze= function() {
    for ( var y= 0; y < mazeHeight; y++ ) {
        maze[y]= [];
        for ( var x= 0; x < mazeWidth; x++ ) {
            if ( Math.random() < .5 ) maze[y][x]= 1;
        }
    }

//     console.table(maze);
}

var pxTileWidth= 48;
var pxTileHeight= 48;

var d= 1;

var ofsX= .1;  // 0 .. 1
var ofyY= .5;

var borderX= 2;
var borderY= 2;

var calcTilePos= function( ofs, pos, p ) {

    var PI_2= Math.PI / 2;

    var pxTargetSize= p.pxTargetSize;
    var pxTileSize= p.pxTileSize;
    var border= p.border;
    var mazeSize= p.mazeSize;

    var pxBorder= border * pxTileSize;
    var pxMazeSize= pxTileSize * mazeSize;
    var pxMazeMove= pxTargetSize - pxMazeSize;

    if ( pxMazeMove > 0 ) pxMazeMove= 0;

    var pxTile0= pxMazeMove * ofs;
    var pxTileN= pxTile0 + pxMazeSize;

    var borderTile0= -1;
    var borderTile1= mazeSize;

    var pxTile= pxTile0;

    // <= !! Ein zusaetzlicher Wert wird noch benoetigt
    for ( var tile= 0; tile <= mazeSize; tile++ ) {

        if ( pxTile < pxBorder ) {
            borderTile0= tile;

            var fTile= (pxTile - pxTile0) / (pxBorder - pxTile0);
            pos[tile]= (1 - Math.sin(PI_2 + PI_2 * fTile)) * pxBorder;
        }
        else if ( pxTile >= pxTargetSize - pxBorder ) {
            if ( borderTile1 == mazeSize ) borderTile1= tile;

            var fTile= (pxTile - pxTileN) / (pxTargetSize - pxBorder - pxTileN);
            pos[tile]= pxTargetSize - (1 - Math.sin(PI_2 + PI_2 * fTile)) * pxBorder;
        }
        else {
            pos[tile]= pxTile;
        }

        pxTile += pxTileSize;
    }

    // Zu breite Tiles abschmaelern (Passiert durch Sinus)
    for ( ; borderTile0 >= 0; borderTile0-- ) {
        if ( pos[borderTile0 + 1] - pos[borderTile0] > pxTileSize ) {
            pos[borderTile0]= pos[borderTile0 + 1] - pxTileSize;
        }
    }

    for ( ; borderTile1 < mazeSize; borderTile1++ ) {
        if ( pos[borderTile1] - pos[borderTile1 - 1] > pxTileSize ) {
            pos[borderTile1]= pos[borderTile1 - 1] + pxTileSize;
        }
    }
}


var fy= function( tileY ) {
    return tileY / mazeHeight * cHeight;
}

// Wiederverwenden, um GC zu entlasten
var posXs= [];
var posYs= [];

var drawMaze= function() {
    var c_= c; // Localize

    calcTilePos(mouseX / cWidth, posXs, {
        pxTargetSize: cWidth,
        pxTileSize: pxTileWidth,
        border: borderX,
        mazeSize: mazeWidth,
    });

    calcTilePos( mouseY / cHeight, posYs, {
        pxTargetSize: cHeight,
        pxTileSize: pxTileHeight,
        border: borderY,
        mazeSize: mazeHeight,
    });

    c.clearRect(0, 0, cWidth, cHeight);

    for ( var y= 0; y < mazeHeight; y++ ) {
        for ( var x= 0; x < mazeWidth; x++ ) {

            var px0= posXs[x];
            var px1= posXs[x + 1]
            var py0= posYs[y];
            var py1= posYs[y + 1]

            if ( maze[y][x] ) {
                c_.fillStyle = 'rgb(' + Math.floor(255 * x / mazeWidth) + ',' + (((x + y) & 1) ? 100 : 0) + ',0)';
            }
            else {
                c_.fillStyle = 'rgb(255,255,255)';
            }
            c_.fillRect(px0, py0, px1 - px0, py1 - py0);
        }
    }
}

var lastTimestamp;
var step= function( timestamp ) {
    if ( !lastTimestamp ) lastTimestamp= timestamp;
    var duration= timestamp - lastTimestamp;
    if ( duration >= 40 ) {

        lastTimestamp= timestamp;

        $('#debug').html(1000 / duration);

        drawMaze();
    }
    window.requestAnimationFrame(step);
}

window.requestAnimationFrame(step);

// setInterval(initMaze, 2000);

var redraw= function() {
    c.strokeStyle = 'blue';
    c.lineWidth = '5';
    c.strokeRect(0, 0, cWidth, cHeight);

    drawMaze();
}

var resizeCanvas= function() {
    canvas.width= cWidth= window.innerWidth;
    canvas.height= cHeight= window.innerHeight;
    redraw();
}

var init= function() {

    initMaze();

    canvas= document.getElementById('stage');
    c= canvas.getContext('2d');

    window.addEventListener('resize', resizeCanvas, false);
    resizeCanvas();

    window.addEventListener('mousemove', function( e ) { mouseX= e.clientX; mouseY= e.clientY; }, false);
}

$(function() {
    init();

});

})();
</script>

<div id="debug"></div>
<canvas id="stage"></canvas>
